<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[HyterMatrix]]></title>
  <link href="https://hyter.me/atom.xml" rel="self"/>
  <link href="https://hyter.me/"/>
  <updated>2019-10-04T11:55:34+08:00</updated>
  <id>https://hyter.me/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Mac MAMP安装libsodium扩展]]></title>
    <link href="https://hyter.me/mac-mamp-install-libsodium-php.html"/>
    <updated>2019-08-28T09:55:55+08:00</updated>
    <id>https://hyter.me/mac-mamp-install-libsodium-php.html</id>
    <content type="html"><![CDATA[
<p>微信支付新的v3版本的接口中加密方式改用了<code>AES-GCM</code>加密算法，在php7.1以上是默认自带的，php7.1以下的就需要安装libsodium-php扩展，这里我们来讲libsodium-php扩展的安装。</p>

<span id="more"></span><!-- more -->

<p>1.在官网下载对应版本的libsodium-php包 </p>

<pre class="line-numbers"><code class="language-text">http://pecl.php.net/get/libsodium-1.0.7.tgz
</code></pre>

<p>2.解压 找到需要的扩展目录 例如我要的是OpenSource</p>

<pre class="line-numbers"><code class="language-shell">cd ~/Desktop/OpenSource/libsodium-1.0.7
</code></pre>

<p>3.执行你所用php版本的phpize 而不是默认的</p>

<pre class="line-numbers"><code class="language-text">/Applications/MAMP/bin/php/php5.6.40/bin/phpize
</code></pre>

<p>4.编译 <code>注意版本</code></p>

<pre class="line-numbers"><code class="language-text">./configure --with-php-config=/Applications/MAMP/bin/php/php5.6.40/bin/php-config 
make
make install
</code></pre>

<p>5.修改MAMP 中php 的扩展加上</p>

<pre class="line-numbers"><code class="language-text">extension=libsodium.so
</code></pre>

<p>如果你和我一样没有./configure 折腾半天，注意看错误提示，<br/>
例如：autoconf 和 m4 没有安装 或者版本 太老</p>

<pre class="line-numbers"><code class="language-text">brew install autoconf
brew install m4
</code></pre>

<p>m4安装之后 记得让MAMP 下面 使用新安装的m4</p>

<pre class="line-numbers"><code class="language-text">cd /Applications/MAMP/Library/bin
mv m4 m4.old
ln -s /usr/local/opt/m4/bin/m4 ./m4
</code></pre>

<p>还有可能 你是没有安装libsodium</p>

<pre class="line-numbers"><code class="language-text">brew install libsodium
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Beyond Compare在Mac OS系统下永久试用]]></title>
    <link href="https://hyter.me/beyond-compare-mac-pojie.html"/>
    <updated>2019-08-23T09:11:41+08:00</updated>
    <id>https://hyter.me/beyond-compare-mac-pojie.html</id>
    <content type="html"><![CDATA[
<p>Beyond Compare 是一个非常好用的一个文件对比软件，但是，免费就30天策略。（资金允许请支持正版授权）</p>

<span id="more"></span><!-- more -->

<p>如果已经安装了的，直接执行 第四步 ，亲测可用<br/>
一、原理<br/>
Beyond Compare每次启动后会先检查注册信息，试用期到期后就不能继续使用。解决方法是在启动前，先删除注册信息，然后再启动，这样就可以永久免费试用了。</p>

<p>二、下载<br/>
首先下载Beyond Compare最新版本，链接如下：<a href="https://www.scootersoftware.com/download.php">https://www.scootersoftware.com/download.php</a></p>

<p>三、安装<br/>
下载完成后，直接安装。</p>

<p>四、创建BCompare文件<br/>
1.进入Mac应用程序目录下，找到刚刚安装好的Beyond Compare，路径如下/Applications/Beyond Compare.app/Contents/MacOS。<br/>
2.修改启动程序文件BCompare为BCompare.real。<br/>
3.在当前目录下新建一个文件BCompare，文件内容如下：</p>

<pre class="line-numbers"><code class="language-bash">#!/bin/bash
rm &quot;/Users/$(whoami)/Library/Application Support/Beyond Compare/registry.dat&quot;
&quot;`dirname &quot;$0&quot;`&quot;/BCompare.real $@
</code></pre>

<p>4.保存BCompare文件。<br/>
5.修改文件的权限：</p>

<pre class="line-numbers"><code class="language-bash">chmod a+x /Applications/Beyond\ Compare.app/Contents/MacOS/BCompare
</code></pre>

<p>以上步骤完成后，再次打开Beyond Compare就可以正常使用了，enjoy it。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac上Django2安装mysqlclient失败 解决方案]]></title>
    <link href="https://hyter.me/15634600813816.html"/>
    <updated>2019-07-18T22:28:01+08:00</updated>
    <id>https://hyter.me/15634600813816.html</id>
    <content type="html"><![CDATA[
<p>今天安装了一下午的mysqlclient一直失败，直到晚上，现在把处理的流程记录一下。</p>

<span id="more"></span><!-- more -->

<pre class="line-numbers"><code class="language-bash"># 安装mysql驱动，你的电脑很可能已经安装过了
brew install mysql-connector-c

# 安装mysqlclient
pip install mysqlclient
</code></pre>

<p>然后万恶的报错了，你懂的。</p>

<pre class="line-numbers"><code class="language-bash">Collecting mysqlclient
  Using cached mysqlclient-1.4.2.tar.gz
    Complete output from command python setup.py egg_info:
    Traceback (most recent call last):
      File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;
      File &quot;/private/var/folders/rv/a_a/T/pip-build-nyaa8t95/mysqlclient/setup.py&quot;, line 17, in &lt;module&gt;
        metadata, options = get_config()
      File &quot;/private/var/folders/rv/a_a/T/pip-build-nyaa8t95/mysqlclient/setup_posix.py&quot;, line 54, in get_config
        libraries = [dequote(i[2:]) for i in libs if i.startswith(&#39;-l&#39;)]
      File &quot;/private/var/folders/rv/a_a/T/pip-build-nyaa8t95/mysqlclient/setup_posix.py&quot;, line 54, in &lt;listcomp&gt;
        libraries = [dequote(i[2:]) for i in libs if i.startswith(&#39;-l&#39;)]
      File &quot;/private/var/folders/rv/a_a/T/pip-build-nyaa8t95/mysqlclient/setup_posix.py&quot;, line 12, in dequote
        if s[0] in &quot;\&quot;&#39;&quot; and s[0] == s[-1]:
    IndexError: string index out of range
</code></pre>

<p>出现这个问题的原因是mysql-connector-c中配置项有误。</p>

<p>具体针对mac来说，你需要顺藤摸瓜找到mysql_config的真身，即/usr/local/Cellar/mysql-connector-c/6.1.11/bin/mysql_config</p>

<pre class="line-numbers"><code class="language-bash">cd /usr/local/Cellar/mysql-connector-c/6.1.11/bin/mysql_config

# 修改前先备份
cp  mysql_config mysql_config.backup

# 使用vi修改配置文件
sudo vi mysql_config

# 114 gg跳转到 114行

将
&gt; # Create options 
&gt; libs=&quot;-L$pkglibdir&quot;
&gt; libs=&quot;$libs -l &quot;

替换为

&gt; # Create options 
&gt; libs=&quot;-L$pkglibdir&quot;
&gt; libs=&quot;$libs -lmysqlclient -lssl -lcrypto&quot;



然后保存即可。

#  然后重新运行mysqlclient安装命令
pip install mysqlclient
</code></pre>

<p>然后还是报错了</p>

<pre class="line-numbers"><code class="language-bash">    ld: library not found for -lssl
    clang: error: linker command failed with exit code 1 (use -v to see invocation)
    error: command &#39;gcc&#39; failed with exit status 1
    ----------------------------------------
ERROR: Command &quot;/Users/wangxiaoming/Desktop/HyterMatrix/Python/mysite/venv/bin/python -u -c &#39;import setuptools, tokenize;__file__=&#39;&quot;&#39;&quot;&#39;/private/var/folders/q0/sp2k72516td35kgjr1h7kty00000gn/T/pip-install-kce8c8yd/mysqlclient/setup.py&#39;&quot;&#39;&quot;&#39;;f=getattr(tokenize, &#39;&quot;&#39;&quot;&#39;open&#39;&quot;&#39;&quot;&#39;, open)(__file__);code=f.read().replace(&#39;&quot;&#39;&quot;&#39;\r\n&#39;&quot;&#39;&quot;&#39;, &#39;&quot;&#39;&quot;&#39;\n&#39;&quot;&#39;&quot;&#39;);f.close();exec(compile(code, __file__, &#39;&quot;&#39;&quot;&#39;exec&#39;&quot;&#39;&quot;&#39;))&#39; install --record /private/var/folders/q0/sp2k72516td35kgjr1h7kty00000gn/T/pip-record-k3eo05p8/install-record.txt --single-version-externally-managed --compile --install-headers /Users/wangxiaoming/Desktop/HyterMatrix/Python/mysite/venv/include/site/python3.6/mysqlclient&quot; failed with error code 1 in /private/var/folders/q0/sp2k72516td35kgjr1h7kty00000gn/T/pip-install-kce8c8yd/mysqlclient/
</code></pre>

<p>似乎没有安装gcc ，安装gcc之前要看装xcode 命令行工具</p>

<pre class="line-numbers"><code class="language-bash">xcode-select --install

# 然后
brew install gcc

#  然后重新运行mysqlclient安装命令
pip install mysqlclient
</code></pre>

<p>然后。。还是报错了</p>

<pre class="line-numbers"><code class="language-bash"> ERROR: Complete output from command /Users/wangxiaoming/Desktop/HyterMatrix/Python/mysite/venv/bin/python -u -c &#39;import setuptools, tokenize;__file__=&#39;&quot;&#39;&quot;&#39;/private/var/folders/q0/sp2k72516td35kgjr1h7kty00000gn/T/pip-install-db871pdy/mysqlclient/setup.py&#39;&quot;&#39;&quot;&#39;;f=getattr(tokenize, &#39;&quot;&#39;&quot;&#39;open&#39;&quot;&#39;&quot;&#39;, open)(__file__);code=f.read().replace(&#39;&quot;&#39;&quot;&#39;\r\n&#39;&quot;&#39;&quot;&#39;, &#39;&quot;&#39;&quot;&#39;\n&#39;&quot;&#39;&quot;&#39;);f.close();exec(compile(code, __file__, &#39;&quot;&#39;&quot;&#39;exec&#39;&quot;&#39;&quot;&#39;))&#39; install --record /private/var/folders/q0/sp2k72516td35kgjr1h7kty00000gn/T/pip-record-jp4c8fy1/install-record.txt --single-version-externally-managed --compile --install-headers /Users/wangxiaoming/Desktop/HyterMatrix/Python/mysite/venv/include/site/python3.6/mysqlclient:
</code></pre>

<p>这里是需要没有openssl的环境变量。如果是用的venv虚拟环境，需要在虚拟环境里添加</p>

<pre class="line-numbers"><code class="language-bash">export LDFLAGS=&quot;-L/usr/local/opt/openssl/lib&quot;
export CPPFLAGS=&quot;-I/usr/local/opt/openssl/include&quot;

#  然后重新运行mysqlclient安装命令
pip install mysqlclient
</code></pre>

<p>这一次终于出现了</p>

<pre class="line-numbers"><code class="language-bash">Successfully installed mysqlclient-1.4.2.post1
</code></pre>

<p>泪奔了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac 设置阿里pip源]]></title>
    <link href="https://hyter.me/mac-pip-source.html"/>
    <updated>2019-07-17T08:19:22+08:00</updated>
    <id>https://hyter.me/mac-pip-source.html</id>
    <content type="html"><![CDATA[
<pre class="line-numbers"><code class="language-shell">mkdir ~/.pip

tee ~/.pip/pip.conf &lt;&lt;-&#39;EOF&#39;
[global]
index-url=http://mirrors.aliyun.com/pypi/simple/
[install]
trusted-host=mirrors.aliyun.com
EOF
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义小尖角]]></title>
    <link href="https://hyter.me/html-jianjiao.html"/>
    <updated>2019-07-16T15:16:51+08:00</updated>
    <id>https://hyter.me/html-jianjiao.html</id>
    <content type="html"><![CDATA[
<pre class="line-numbers"><code class="language-markup">.icon{
     display:inline-block;
     border-top:15px solid red;
     border-right:15px solid transparent;
     border-bottom:15px solid transparent;
     border-left:15px solid transparent;
}

&lt;div class=&quot;icon&quot;&gt;&lt;/div&gt;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[调用iconv和mb_convert_encoding会显示乱码或空白]]></title>
    <link href="https://hyter.me/php-iconv-qa.html"/>
    <updated>2019-07-16T15:11:41+08:00</updated>
    <id>https://hyter.me/php-iconv-qa.html</id>
    <content type="html"><![CDATA[
<p>比如“珺”字在单纯的调用iconv 和mb_convert_encoding会显示乱码或空白，解决办法：</p>

<pre class="line-numbers"><code class="language-php">$name = iconv(&quot;utf-8&quot;,&quot;gbk//IGNORE&quot;,$str);
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP关于SSH和SFTP相关方法]]></title>
    <link href="https://hyter.me/php-sftp.html"/>
    <updated>2019-07-16T15:08:00+08:00</updated>
    <id>https://hyter.me/php-sftp.html</id>
    <content type="html"><![CDATA[
<p>php支持ssh和sftp推送，原生不支持，需要装pecl的ssh2扩展。</p>

<ol>
<li>扩展安装：</li>
<li>SSH使用：</li>
</ol>

<pre class="line-numbers"><code class="language-php">extension_loaded(&#39;ssh2&#39;) #检查是否安装ssh2扩展模块
$conn = ssh2_connect(IP, PORT) #连接远程服务器，看是否网络通，返回连接资源
ssh2_auth_password($conn, $username, $password) #通过账号密码认证登陆远程远程服务
$ssh2_sft = ssh2_sftp($conn);# 获取sftp连接资源
ssh2_sftp_mkdir($ssh2_sftp, $path, 0777, true)#创建远程目录
ssh2_scp_send($conn, $localfile, $filename, 0777)#上传文件
</code></pre>

<p>在一些特殊情况下，比如在内网，外网主机被映射为内网一个内网ip时，ssh2_scp_send可能推送不出文件，并且还会一直发送，长时间不会返回上传状态，这个时候需要用使用sftp方式推送</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSA公钥格式PKCS#1,PKCS#8互转说明]]></title>
    <link href="https://hyter.me/rsa-pkcs1-to-pkcs8.html"/>
    <updated>2019-07-15T07:50:49+08:00</updated>
    <id>https://hyter.me/rsa-pkcs1-to-pkcs8.html</id>
    <content type="html"><![CDATA[
<p>PKCS#1 转 PKCS#8:</p>

<pre class="line-numbers"><code class="language-shell">openssl rsa -RSAPublicKey_in -in &lt;filename&gt; -pubout
</code></pre>

<p>PKCS#8 转 PKCS#1:</p>

<pre class="line-numbers"><code class="language-shell">openssl rsa -pubin -in &lt;filename&gt; -RSAPublicKey_out
</code></pre>

<span id="more"></span><!-- more -->

<p>PKCS#1 格式密钥：</p>

<pre class="line-numbers"><code class="language-text">-----BEGIN RSA PUBLIC KEY-----
MIIBCgKCAQEArT82k67xybiJS9AD8nNAeuDYdrtCRaxkS6cgs8L9h83eqlDTlrdw
zBVSv5V4imTq/URbXn4K0V/KJ1TwDrqOI8hamGB0fvU13WW1NcJuv41RnJVua0QA
lS3tS1JzOZpMS9BEGeFvyFF/epbi/m9+2kUWG94FccArNnBtBqqvFncXgQsm98JB
3a62NbS1ePP/hMI7Kkz+JNMyYsWkrOUFDCXAbSZkWBJekY4nGZtK1erqGRve8Jbx
TWirAm/s08rUrjOuZFA21/EI2nea3DidJMTVnXVPY2qcAjF+595shwUKyTjKB8v1
REPB3hPF1Z75O6LwuLfyPiCrCTmVoyfqjwIDAQAB
-----END RSA PUBLIC KEY-----
</code></pre>

<p>PKCS#8 格式密钥：</p>

<pre class="line-numbers"><code class="language-text">-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArT82k67xybiJS9AD8nNA
euDYdrtCRaxkS6cgs8L9h83eqlDTlrdwzBVSv5V4imTq/URbXn4K0V/KJ1TwDrqO
I8hamGB0fvU13WW1NcJuv41RnJVua0QAlS3tS1JzOZpMS9BEGeFvyFF/epbi/m9+
lkUWG94FccArNnBtBqqvFncXgQsm98JB3a42NbS1ePP/hMI7Kkz+JNMyYsWkrOUF
DCXAbSZkWBJekY4nGZtK1erqGRve8JbxTWirAm/s08rUrjOuZFA21/EI2nea3Did
JMTVnXVPY2qcAjF+595shwUKyTjKB8v1REPB3hPF1Z75O6LwuLfyPiCrCTmVoyfq
jwIDAQAB
-----END PUBLIC KEY-----
</code></pre>

<p>转载自<a href="https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=24_7">微信支付</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MAC下ssh报错，清除原有ssh密钥方法]]></title>
    <link href="https://hyter.me/mac-clear-ssh-keygen.html"/>
    <updated>2019-07-09T18:12:50+08:00</updated>
    <id>https://hyter.me/mac-clear-ssh-keygen.html</id>
    <content type="html"><![CDATA[
<p>mac的终端下面使用ssh user@localhost输入密码不能正常登录解决.<br/>
可可能由于远程服务器更换了证书或者重装服务器了，导致了证书变更了。<br/>
解决方法：</p>

<pre class="line-numbers"><code class="language-shell">ssh-keygen -R 192.168.1.203(你远程服务器的IP)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pem转pfx]]></title>
    <link href="https://hyter.me/pem-to-pfx.html"/>
    <updated>2019-07-03T17:15:56+08:00</updated>
    <id>https://hyter.me/pem-to-pfx.html</id>
    <content type="html"><![CDATA[
<pre class="line-numbers"><code class="language-shell">openssl req -new -key privkey.pem -out root.csr 
 
openssl x509 -req -days 3650 -sha1 -extensions v3_ca -signkey privkey.pem -in root.csr -out root.crt 
 
openssl pkcs12 -export -in root.crt -inkey privkey.pem -out  an.pfx 
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP代码 ping 域名]]></title>
    <link href="https://hyter.me/php-ping-code.html"/>
    <updated>2019-06-19T15:58:32+08:00</updated>
    <id>https://hyter.me/php-ping-code.html</id>
    <content type="html"><![CDATA[
<p>在PHP代码中做ping</p>

<pre class="line-numbers"><code class="language-php">// ping 域名
function pingAddress($address,$proxy=false) {
    $status = -1;
        if (strcasecmp(PHP_OS, &#39;WINNT&#39;) === 0) {
            // Windows 服务器下
            $pingresult = exec(&quot;ping -n 1 {$address}&quot;, $outcome, $status);
        } elseif (strcasecmp(PHP_OS, &#39;Linux&#39;) === 0) {
            // Linux 服务器下
            $pingresult = exec(&quot;ping -c 1 {$address}&quot;, $outcome, $status);
        }elseif (strcasecmp(PHP_OS, &#39;Darwin&#39;) === 0){
            // MacOS 下
            $pingresult = exec(&quot;ping -c 1 {$address}&quot;, $outcome, $status);
        }
        if (0 == $status) {
            $status = true;
        } else {
            $status = false;
        }
    return $status;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用git把某一次commit修改过的文件打包]]></title>
    <link href="https://hyter.me/git-diff-file-tar.html"/>
    <updated>2018-12-12T09:38:34+08:00</updated>
    <id>https://hyter.me/git-diff-file-tar.html</id>
    <content type="html"><![CDATA[
<p>把新增加的文件使用git add添加进改动</p>

<p>使用git commit提交改动</p>

<p>使用<code>git log</code>查看提交的commit id</p>

<p>使用命令</p>

<pre class="line-numbers"><code class="language-git">git diff-tree -r --no-commit-id --name-only [commit id] | xargs tar -rf mytarfile.tar

# or

git diff [old commit id] [commit id]  --name-only | xargs tar -czvf mytarfile.tar.gz
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[中兴ZXHN F650设备管理密码]]></title>
    <link href="https://hyter.me/ZXHN-F650-Admin-Password.html"/>
    <updated>2019-02-15T09:00:02+08:00</updated>
    <id>https://hyter.me/ZXHN-F650-Admin-Password.html</id>
    <content type="html"><![CDATA[
<p>账号：telecomadmin<br/>
密码：nE7jA%5m%</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[命令迁移模块]]></title>
    <link href="https://hyter.me/python-pip-freeze.html"/>
    <updated>2019-02-15T08:15:27+08:00</updated>
    <id>https://hyter.me/python-pip-freeze.html</id>
    <content type="html"><![CDATA[
<p>生成requirements.txt文件 保存当前环境所依赖的类库</p>

<pre class="line-numbers"><code class="language-text">pip freeze &gt;requirements.txt
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[更新anaconda及所有包]]></title>
    <link href="https://hyter.me/update-anaconde-pkgs.html.html"/>
    <updated>2019-02-14T09:03:17+08:00</updated>
    <id>https://hyter.me/update-anaconde-pkgs.html.html</id>
    <content type="html"><![CDATA[
<pre class="line-numbers"><code class="language-text">##################################
# 更新Anaconda
conda update conda

# 更新所有包
conda update --all

##################################

# 添加清华源
# 执行以下命令
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
conda config --set show_channel_urls yes
# https://blog.csdn.net/qq_18941425/article/details/80201966

##################################
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift编程入门（13）枚举]]></title>
    <link href="https://hyter.me/swift-learning-13.html"/>
    <updated>2019-01-17T12:28:44+08:00</updated>
    <id>https://hyter.me/swift-learning-13.html</id>
    <content type="html"><![CDATA[
<p>你已经见过Swift提供的所有内建类型了，比如整数、字符串、数组和字典等。下面几章会展示这门语言创建自定义类型的能力。本章关注的重点是枚举（enumeration或者enum）。枚举能让你创建属于明确定义的几种情形之一的实例。<br/>
<span id="more"></span><!-- more --></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift编程入门（12）闭包]]></title>
    <link href="https://hyter.me/swift-learning-12.html"/>
    <updated>2019-01-09T21:00:39+08:00</updated>
    <id>https://hyter.me/swift-learning-12.html</id>
    <content type="html"><![CDATA[
<p><code>闭包（closure）</code>是在应用中完成特定任务的互相分离的功能组。上一章学习的函数是闭包的<br/>
特殊情况，可以把函数理解为有名字的闭包。<br/>
<span id="more"></span><!-- more --></p>

<ul>
<li>
<a href="#toc_0">闭包的语法</a>
</li>
<li>
<a href="#toc_1">闭包表达式语法</a>
</li>
<li>
<a href="#toc_2">函数作为返回值</a>
</li>
<li>
<a href="#toc_3">函数作为参数</a>
</li>
<li>
<a href="#toc_4">闭包能捕获变量</a>
</li>
<li>
<a href="#toc_5">闭包是引用类型</a>
</li>
<li>
<a href="#toc_6">函数式编程</a>
</li>
</ul>


<h2 id="toc_0">闭包的语法</h2>

<p>想象你是一个社区组织者，负责管理若干组织。你想记录每个组织有多少名志愿者，因此创建了一个数组来完成这个任务.</p>

<pre class="line-numbers"><code class="language-swift">import Cocoa
let volunteerCounts = [1,3,40,32,2,53,77,13]
</code></pre>

<p>你输入了每个组织提供的志愿者人数，这意味着这个数组是完全无序的。如果志愿者数组能按人数从小到大排序就好了。好消息是，Swift提供了sorted(by:)方法来指定如何排列数组。<br/>
sorted(by:)接受一个参数：一个描述如何排序的闭包。这个闭包接受两个参数，其类型必须和数组元素的类型匹配，并返回布尔值。通过比较两个参数会生成返回值，表示第一个参数是否排在第二个参数前面。如果想让参数一排在参数二前面，可以在返回的时候使用&lt;；这样会把数组按升序（ascending）排列，也就是从小到大排序。如果想让参数二排在参数一前面，可以在返回的时候使用&gt;；这样会把数组按降序（desending）排列，也就是从大到小排序<br/>
因为志愿者人数的数组中都是整数，所以sorted(by:)的函数类型应该类似于((Int, Int) -&gt; Bool) -&gt; [Int]。读出来就是“sorted(by:)是一个接受两个整数进行比较并返回布尔值表示哪个整数在前的闭包”。sorted(by:)返回一个新的整数数组，这些整数已经根据闭包定义的规则排好序了。</p>

<pre class="line-numbers"><code class="language-swift">import Cocoa 
let volunteerCounts = [1,3,40,32,2,53,77,13] 
func sortAscending(_ i: Int, _ j: Int) -&gt; Bool { 
    return i &lt; j 
} 
let volunteersSorted = volunteerCounts.sorted(by: sortAscending) 
</code></pre>

<p>首先，我们创建了函数sortAscending(_:_:)。这个函数比较两个整数并返回一个布尔值表示整数i是否应该在整数j前面。因为sortAscending这个名字已经意味着我们是在对两个实例排序，所以可以用_省去在调用时的参数名。如果i小于j从而应该排在j前面的话，这个函数就会返回true。这个全局函数是一个命名闭包（回忆一下，所有的函数都是闭包），因此可以将其作为sorted(by:)的参数。<br/>
接着，调用sorted(by:)，把sortAscending(_:_:)作为第二个参数传递。因为sorted(by:)返回一个新数组，所以需要把结果赋给新的常量数组volunteersSorted。这个实例保存组织内排过序的志愿者人数。</p>

<h2 id="toc_1">闭包表达式语法</h2>

<pre class="line-numbers"><code class="language-swift">{(parameters) -&gt; return type in 
    // 代码
} 
</code></pre>

<p>闭包表达式写在花括号（{}）里。紧跟着左花括号的圆括号里是闭包的参数。闭包的返回值类型在参数后面，和常规语法一样。关键字in用来分隔闭包的参数、返回值与闭包体内的语句。<br/>
重构上面排序的代码</p>

<pre class="line-numbers"><code class="language-swift">import Cocoa 
let volunteerCounts = [1,3,40,32,2,53,77,13] 

let volunteersSorted = volunteerCounts.sorted(by: { 
(i: Int, j: Int) -&gt; Bool in 
return i &lt; j 
}) 
</code></pre>

<p>这段代码比第一个版本稍微清晰和优雅一些。我们没有提供在playground中其他地方定义的函数，而是在sorted(by:)方法的第二个参数中实现了一个内联闭包。我们在闭包的圆括号中定义了其参数及类型（Int)，也指定了返回值类型。接着，用逻辑测试（i是否比j小？）来确定闭包的返回值，从而实现闭包体。<br/>
结果跟之前一样：把排好序的数组赋给了volunteersSorted。<br/>
这次重构在正确的方向上迈进了一步，但还是有点冗长。闭包可以利用Swift的类型推断系统，因此我们可以通过去除类型信息来进一步简化闭包。</p>

<pre class="line-numbers"><code class="language-swift">import Cocoa 
let volunteerCounts = [1,3,40,32,2,53,77,13] 
let volunteersSorted = volunteerCounts.sorted(by: { i, j in i &lt; j })
</code></pre>

<p>这段代码改动了三处。首先，移除了两个参数和返回值的类型信息。返回值类型可以移除是因为编译器知道检查i &lt; j是否成立会返回布尔值true或false。其次，把整个闭包表达式放到了一行。<br/>
最后，移除了关键字return。不是所有的闭包语句都可以省略return关键字，这里可以是因为只有一个表达式（i &lt; j）。如果存在更多表达式，那么显式的return就是必需的。<br/>
这个闭包现在变得很紧凑，但是还可以继续优化。Swift提供了快捷参数名，可以在内联闭包表达式中引用。这些快捷参数名和显式声明的参数类似：类型和值都一样。编译器的类型推断能力让它知道闭包接受的参数个数和类型，这意味着不需要给参数命名。<br/>
举个例子，编译器知道sorted(by:)接受一个闭包。这个闭包本身又接受两个参数，它们的类型和sorted(by:)方法的数组参数中的元素类型一样。因为闭包有两个参数，我们能比较其值来判断顺序，所以可以用$0引用第一个参数的值，用$1引用第二个参数的值。</p>

<pre class="line-numbers"><code class="language-swift">import Cocoa 
let volunteerCounts = [1,3,40,32,2,53,77,13] 
let volunteersSorted = volunteerCounts.sorted(by: { $0 &lt; $1 })
</code></pre>

<p>这种<code>尾部闭包语法（trailing closure syntax）</code>对于闭包体很长的情况特别有用。在这里，尾部闭包只是让我们少输入了两个圆括号。</p>

<h2 id="toc_2">函数作为返回值</h2>

<h2 id="toc_3">函数作为参数</h2>

<h2 id="toc_4">闭包能捕获变量</h2>

<h2 id="toc_5">闭包是引用类型</h2>

<h2 id="toc_6">函数式编程</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift编程入门（11）函数]]></title>
    <link href="https://hyter.me/swift-learning-11.html"/>
    <updated>2018-12-26T09:08:58+08:00</updated>
    <id>https://hyter.me/swift-learning-11.html</id>
    <content type="html"><![CDATA[
<p><code>函数（function）</code>是一组有名字的代码，用来完成某个特定的任务。函数的名字描述了其执行的任务。前面已经用过一些函数，比如Swift提供的<code>print()</code>，以及我们所写代码创建的其他函数。<br/>
函数会执行代码。有些函数会定义参数，用来传递数据以帮助函数完成工作。有些函数在完成工作后会返回一些信息。可以把函数理解为一部小机器，打开后，它就开始运转并完成自己的工作。如果它的工作方式需要数据的话，就要给它传入数据，然后它会返回一块新数据作为工作成果。<br/>
<span id="more"></span><!-- more --></p>

<ul>
<li>
<a href="#toc_0">一个基本函数</a>
</li>
<li>
<a href="#toc_1">函数参数</a>
<ul>
<li>
<a href="#toc_2">参数的名字</a>
</li>
<li>
<a href="#toc_3">变长参数</a>
</li>
<li>
<a href="#toc_4">默认参数值</a>
</li>
<li>
<a href="#toc_5">in-out 参数</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">从函数返回</a>
</li>
<li>
<a href="#toc_7">嵌套函数和作用域</a>
</li>
<li>
<a href="#toc_8">多个返回值</a>
</li>
<li>
<a href="#toc_9">可空返回值类型</a>
</li>
<li>
<a href="#toc_10">提前退出函数</a>
</li>
<li>
<a href="#toc_11">函数类型</a>
</li>
</ul>


<h2 id="toc_0">一个基本函数</h2>

<p>定义一个函数</p>

<pre class="line-numbers"><code class="language-swift">import Cocoa 
func printGreeting() {
    print(&quot;Hello, playground.&quot;)
}
printGreeting()
</code></pre>

<p>这段代码用<code>func</code>关键字后跟函数名字<code>printGreeting()</code>来定义一个函数。圆括号是空的，因为这个函数不接受任何参数。（稍后会详细介绍参数。）<br/>
左花括号（{）代表函数实现的开始。你可以在这里写代码，描述函数如何工作。调用函数时，花括号中的代码会执行。printGreeting()函数非常简单，只有一行代码，利用print()来打印Hello, playground.到控制台。<br/>
最后调用函数，让它执行内部的代码。</p>

<h2 id="toc_1">函数参数</h2>

<p>函数有参数（parameter）之后就能做更多的事情了。利用参数可以向函数输入数据。我们之所以把函数的这部分称为“参数”，是因为它们可以根据调用者给函数传递的数据来改变自己的值。函数利用传递给自己的参数来执行任务或产生结果。</p>

<pre class="line-numbers"><code class="language-swift">import Cocoa
func printGreeting() {
    print(&quot;Hello, playground.&quot;)
}
printGreeting()
func printPersonalGreeting(name: String) {
    print(&quot;Hello \(name), welcome to your playground.&quot;)
}
printPersonalGreeting(name: &quot;Matt&quot;)
</code></pre>

<p><code>printPersonalGreeting(name:)</code>接受一个参数，如函数名后面的圆括号中所示。<code>实参（argument）</code>是调用者传递给函数<code>形参（parameter）</code>的值。本例的函数有一个String类型的形参name。在紧随着name的:后面指定其类型，跟指定变量和常量的类型一样。</p>

<p>定义一个除法函数</p>

<pre class="line-numbers"><code class="language-swift">func divisionDescriptionFor(numerator: Double, denominator: Double) {
    print(&quot;\(numerator) divided by \(denominator) equals \(numerator / denominator)&quot;)
}
divisionDescriptionFor(numerator: 9.0, denominator: 3.0)
</code></pre>

<h3 id="toc_2">参数的名字</h3>

<p>函数的参数有名字。比如，函数<code>divisionDescriptionFor(numerator:denominator:)</code>有两个参数，参数名分别是<code>numerator</code>和<code>denominator</code>。在用<code>divisionDescriptionFor(numerator: denominator:)</code>时，我们同时用到了两个参数的名字。这是因为在默认情况下调用函数时会用到所有的参数名。<br/>
有时候让函数体外可见的参数名不同于内部也是有用的。也就是说调用函数的时候用一个参数名字，在函数体内用另一个名字。这种参数被称为<code>外部参数</code>。<br/>
外部参数能让函数可读性更高——如果名字起得合适的话。眼下在调用<code>printPersonalGreeting(name:)</code>时可见的参数名还算能提供有用的信息，但是可读性并不强。通常应该让代码读起来跟我们平常说话一样。</p>

<pre class="line-numbers"><code class="language-swift">func printPersonalGreeting(to name: String) {
    print(&quot;Hello \(name), welcome to your playground.&quot;)
}
printPersonalGreeting(to: &quot;Matt&quot;)
</code></pre>

<p>现在<code>printPersonalGreeting(to:)</code>有了一个外部参数to:。这个参数能让函数读起来更像日常说话：“Print personal greeting to Matt.”在函数内，还是得使用name。这样实际上很好，在函数内部，name的含义很清楚。如果在printPersonalGreeting的内部出现print(&quot;Hello \ (to), welcome to your playground.&quot;)的话反而会让人困惑。</p>

<h3 id="toc_3">变长参数</h3>

<p><code>变长（variadic）</code>参数接受零个或更多输入值作为实参。函数只能有一个变长参数，而且一般应该是参数列表中的最后一个。参数值在函数内部以数组的形式可用。<br/>
要声明变长参数，用参数类型后面的三个点表示，如names: String...。在本例中，name在函数体内可用，类型是[String]。</p>

<pre class="line-numbers"><code class="language-swift">func printPersonalGreetings(to names: String...) {
    for name in names {
        print(&quot;Hello \(name), welcome to the playground.&quot;)
    }
} 
printPersonalGreetings(to: &quot;Alex&quot;,&quot;Chris&quot;,&quot;Drew&quot;,&quot;Pat&quot;)
</code></pre>

<h3 id="toc_4">默认参数值</h3>

<p>Swift的参数可以接受默认值。默认值应该放在函数参数列表的末尾。如果形参有默认值，那么在调用函数时可以省略实参。（你可能已经猜到了，函数在这种情况下会使用参数的默认值。）</p>

<pre class="line-numbers"><code class="language-swift">func divisionDescriptionFor(numerator: Double, denominator: Double, withPunctuation punctuation: String = &quot;.&quot;) {
    print(&quot;\(numerator) divided by \(denominator) equals \(numerator/denominator) \(punctuation) &quot;)
}
divisionDescriptionFor(numerator: 9.0, denominator: 3.0)
divisionDescriptionFor(numerator: 9.0, denominator: 3.0,withPunctuation: &quot;!&quot;)
</code></pre>

<p>现在函数接受三个参数：divisionDescriptionFor(numerator:denominator:withPunctuation:)。注意新增代码：punctuation: String = &quot;.&quot;。我们为标点增加了一个新参数，加上其期望的类型，并且用= &quot;.&quot;语法给了它一个默认值。这意味着这个函数创建的字符串默认会以句号结尾。</p>

<h3 id="toc_5">in-out 参数</h3>

<p>出于某种原因，函数有时候需要修改实参的值。<code>in-out参数（in-out parameter）</code>能让函数影响函数体以外的变量。有两个注意事项：首先，in-out参数不能有默认值；其次，变长参数不能标记为inout。假设有一个函数接受一个错误信息作为实参，并根据某些条件在后面添加信息。</p>

<pre class="line-numbers"><code class="language-swift">var error = &quot;The request failed:&quot;
func appendErrorCode(_ code: Int, toErrorString errorString: inout String) {
    if code == 400 {
        errorString += &quot; bad request.&quot;
    }
}
appendErrorCode(400, toErrorString: &amp;error)
error
</code></pre>

<p>函数appendErrorCode(_:toErrorString:)有两个参数。第一个是函数要比较的错误码，类型为Int。注意，我们给这个参数的外部名是_。它在Swift中有特殊含义：在参数名前用_会使得函数被调用时省去外部名。由于这个参数名是跟在函数名后面的，在调用的时候没有理由用到这个名字。第二个是命名为toErrorString的inout参数（在名字前用inout关键字标记），类型为String。toErrorString是外部名，用来调用函数；而errorString是内部名，在函数内部使用。<br/>
inout加在String前面表示这个函数期望一个特殊的String：它需要一个inout的String。调用这个函数时，传递给inout参数的变量需要在前面加上&amp;。这表示函数会修改这个变量。在这里，errorString被改为The request failed: bad request，可以在运行结果侧边栏看到。</p>

<h2 id="toc_6">从函数返回</h2>

<p>函数结束执行后可以返回一些信息。这些信息称为函数的返回值（return）。常见的情况是写下一个函数来完成一些工作，然后返回一些数据。让divisionDescriptionFor(numerator: denominator:withPunctuation:)函数返回一个String类型的实例。</p>

<pre class="line-numbers"><code class="language-swift">func divisionDescriptionFor(numerator: Double, denominator: Double, withPunctuation punctuation: String = &quot;.&quot;) -&gt; String {return &quot;\(numerator) divided by \(denominator) equals \(numerator / denominator)\(punctuation)&quot; }
print(divisionDescriptionFor(numerator: 9.0, denominator: 3.0, withPunctuation: &quot;!&quot;))
</code></pre>

<p>新函数的功能和之前差不多，只有一个变化：新实现有返回值。返回值用-&gt; String语法表示，表明函数会返回指定类型的实例。因为要输出字符串到控制台，所以这个函数返回String。返回字符串的细节在函数体内。<br/>
因为divisionDescriptionFor(numerator:denominator:withPunctuation:)返回String，并且print()的参数类型为String，所以可以在print()的调用中再调用除法函数，把字符串输出到控制台。</p>

<h2 id="toc_7">嵌套函数和作用域</h2>

<p>Swift的函数定义可以嵌套。嵌套函数在另一个函数定义的内部声明并实现。嵌套函数在包围它的函数以外不可用。当你需要一个函数只在另一个函数内部做一些事情时，这个特性很有用。</p>

<pre class="line-numbers"><code class="language-swift">func areaOfTriangleWith(base: Double, height: Double) -&gt; Double {
    let numerator = base * height
    func divide() -&gt; Double {
        return numerator / 2
    }
    return divide()
}
areaOfTriangleWith(base: 3.0, height: 5.0)
</code></pre>

<p>函数areaOfTriangleWith(base:height:)接受两个参数作为底和高，类型是Double。它还会返回一个Double。在函数内部实现中，我们声明并实现了另一个函数，名为divide()。这个函数没有参数，返回一个Double。函数areaOfTriangleWith(base:height:)调divide()函数并返回结果。<br/>
divide()函数还用到了areaOfTriangleWith(base:height:)中定义的常量numerator。这样为什么能行？<br/>
这个常量是在divide()的闭合作用域中定义的。函数中花括号（{}）内部的一切都称为被函数的作用域包围。在本例中，常量numerator和函数divide()都被areaOfTriangle(withBase: andHeight:)的作用域包围。<br/>
函数的作用域描述了实例或函数的可见性，这是某种范围。任何定义在函数作用域内部的东西都对函数可见，除此以外的一切都超出了函数的可见范围。numerator对函数divide()可见是因为两者共享同一个闭合作用域。<br/>
另一方面，因为divide()函数定义在areaOfTriangleWith(base:height:)函数作用域内部，所以在外面是不可见的。如果试图在包围的函数外部调用divide()函数，编译器会报错。可以试一下看看这个错误。<br/>
divide()是个很简单的函数。事实上，areaOfTriangleWith(base:height:)不需要它就可以得到同样的结果：return (base * height) / 2。这里要关注的焦点是作用域的原理。</p>

<h2 id="toc_8">多个返回值</h2>

<p>函数可以返回不止一个值。Swift用元组数据类型来做到这一点，第5章已经介绍过了。回忆一下，元组是相关值的有序列表。</p>

<pre class="line-numbers"><code class="language-swift">func sortedEvenOddNumbers(_ numbers: [Int]) -&gt; (evens: [Int], odds: [Int]) {
    var evens = [Int]()
    var odds = [Int]()
    for number in numbers {
        if number % 2 == 0 {
            evens.append(number)
        } else {
            odds.append(number)
        }
    }
    return (evens, odds)
}
</code></pre>

<p>首先声明一个叫作<code>sortedEvenOddNumbers(_:)</code>的函数。这个函数接受一个整数数组作为唯一的参数，并返回一个命名元组（named tuple）。元组的组成部分是有名字的，可以从这一点看出这是一个命名元组：evens是整数数组，odds也是整数数组。<br/>
接着，在函数的内部实现中初始化evens和odds数组，准备存放相应的整数。然后遍历函数参数numbers里的整数数组，每循环一次，就用%运算符检查number的奇偶性。如果结果是偶数，就添加到evens数组；如果不是偶数，就添加到odds数组。<br/>
我们来调用一下这个函数</p>

<pre class="line-numbers"><code class="language-swift">let aBunchOfNumbers = [10,1,4,3,57,43,84,27,156,111]
let theSortedNumbers = sortedEvenOddNumbers(aBunchOfNumbers)
print(&quot;The even numbers are: \(theSortedNumbers.evens); the odd numbers are: \(theSortedNumbers.odds)&quot;)
</code></pre>

<p>首先创建一个Array类型的实例存放一组整数。接着把数组传递给sortedEvenOddNumbers(_:)函数，并将返回值赋给常量theSortedNumbers。因为返回值指定为(evens: [Int], odds: [Int])，所以编译器推断新创建的常量就是这个类型。最后把结果打印到控制台。</p>

<h2 id="toc_9">可空返回值类型</h2>

<p>有时候，我们想让函数返回可空实例。如果一个函数在某些情况下返回nil，在其他情况下返回一个值的话，Swift提供了可空返回值以供使用。</p>

<pre class="line-numbers"><code class="language-swift">func grabMiddleName(fromFullName name: (String, String?, String)) -&gt; String? {
    return name.1
}
let middleName = grabMiddleName(fromFullName: (&quot;Matt&quot;,nil,&quot;Mathias&quot;))
if let theName = middleName {
    print(theName)
}
</code></pre>

<p>这段代码创建了一个名为<code>grabMiddleName(fromFullName:)</code>的函数。这个函数跟之前的有所不同，它接受一个参数：元组类型(String, String?, String)。元组的三个String实例分别是名字、中间名和姓，而中间名为可空类型。<br/>
<code>grabMiddleName(fromFullName:)</code>函数的这个参数叫 <code>name</code> ，有个外部参数名叫<code>fromFullName</code>。在函数内部实现中可以用要返回名字的索引访问这个参数。元组是零索引的，因此用1来访问实参里的中间名。因为中间名可以是nil，所以函数的返回值可空。<br/>
然后调用grabMiddleName(fromFullName:)并传递名字、中间名和姓（可以随意改名字）。因为元组的中间名部分声明为String?，所以可以传递nil。元组的名字和姓部分都不能传<code>nil</code>。<br/>
控制台没有打印东西。因为中间名是nil，可空实例绑定中的布尔值不为真，所以<code>print()</code>不会执行。</p>

<h2 id="toc_10">提前退出函数</h2>

<p><code>guard语句</code>。跟<code>if/else</code>语句一样，guard语句会根据某个表达式返回的布尔值结果来执行代码；但不同之处是，如果某些条件没有满足，可以用guard语句来提前退出函数，这也是其名称的由来。可以把guard语句想象成一种防止代码在某种不当条件下运行的方式。</p>

<pre class="line-numbers"><code class="language-swift">func greetByMiddleName(fromFullName name: (first: String,middle: String?,last: String)) {
    guard let middleName = name.middle else {
        print(&quot;Hey there!&quot;)
        return
    }
    print(&quot;Hey \(middleName)&quot;)
}
greetByMiddleName(fromFullName: (&quot;Matt&quot;,&quot;Danger&quot;,&quot;Mathias&quot;))
</code></pre>

<p><code>greetByMiddleName(fromFullName:)</code>类似于<code>grabMiddleName(fromFullName:)</code>，都接受一样的参数；但不同的是前者没有返回值。另一个区别是元组name中的元素有名字，跟人名的各个部分一致。如你所见，这些元素名字在函数内部可用。<br/>
guard let middleName = name.middle这行代码把middle的值绑定到middleName常量上。如果可空实例没有值，那么guard语句中的代码会执行。这样会在控制台打印一句省略了中间名的问候语：Hey there!。之后，用return从函数显式返回，这表示guard语句所要求的条件没有满足，函数需要提前返回。<br/>
可以把gurad语句想象成防止以下尴尬情况发生：我们在不知道某人中间名的情况下只能含糊应付过去。不过如果元组带着中间名传递给函数，那么其值会绑定到middleName上，并且在guard语句后可用。这意味着middleName在包围着gurad语句的父作用域中可见。<br/>
不过，在调用greetByMiddleName(fromFullName:)函数时，会给元组name一个中间名并传递给函数。这意味着控制台会打印“Hey Danger!”。如果中间名是nil，那么控制台会打印&quot;Hey there!&quot;。</p>

<h2 id="toc_11">函数类型</h2>

<p><code>函数类型（function type）</code>由函数参数和返回值组成。以sortedEvenOddNumbers(_:)函数为例，它接受整数数组作为参数，返回有两个整数数组的元组。于是sortedEvenOddNumbers(_:)的类型可以表示为：([Int]) -&gt; ([Int], [Int])。<br/>
函数参数在左边的圆括号中列出，返回值类型跟在-&gt;后面。可以这么读这个函数类型：“一个接受整数数组作为参数并返回带有两个整数数组的元组的函数。”作为比较，既没有参数也没有返回值的函数类型是：() -&gt; ()。<br/>
函数类型很有用，我们可以把函数类型实例赋给变量。在下一章中，当你看到函数可以作为参数和其他函数的返回值时，会意识到这个特性尤其有用。就目前而言，只要知道如何把函数类型实例赋给常量就可以了。<br/>
<code>let evenOddFunction: ([Int]) -&gt; ([Int], [Int]) = sortedEvenOddNumbers</code><br/>
这行代码创建了一个evenOddFunction常量，其值是sortedEvenOddNumbers(_:)函数。很酷，是吧？现在可以传递常量了，就跟普通常量一样；甚至可以用这个常量来调用函数。举个例子，evenOddFunction(numbers: [1,2,3])会把作为参数传递的数组中的数字放进有两个数组的元组中——一个数组放奇数，另一个放偶数。</p>

<pre class="line-numbers"><code class="language-swift">func sortedEvenOddNumbers(_ numbers: [Int]) -&gt; (evens: [Int], odds: [Int]) {
    var evens = [Int]()
    var odds = [Int]()
    for number in numbers {
        if number % 2 == 0 {
            evens.append(number)
        } else {
            odds.append(number)
        }
    }
    return (evens, odds)
}

let evenOddFunction: ([Int]) -&gt; ([Int], [Int]) = sortedEvenOddNumbers
evenOddFunction([1,2,3])
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift编程入门（10）集合]]></title>
    <link href="https://hyter.me/swift-learning-10.html"/>
    <updated>2018-12-20T21:18:09+08:00</updated>
    <id>https://hyter.me/swift-learning-10.html</id>
    <content type="html"><![CDATA[
<p>Swift提供的第三种容器类型是集合（set）。集合是一组互不相同的实例的无序组合。这个定义将其与数组区别开来，后者是有序的，并且可以容纳重复的值。<br/>
<span id="more"></span><!-- more --></p>

<ul>
<li>
<a href="#toc_0">创建集合</a>
</li>
<li>
<a href="#toc_1">运用集合</a>
<ul>
<li>
<a href="#toc_2">合并</a>
</li>
<li>
<a href="#toc_3">交集</a>
</li>
<li>
<a href="#toc_4">不相交</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">创建集合</h2>

<pre class="line-numbers"><code class="language-swift">import Cocoa 
var groceryBag = Set&lt;String&gt;() 
</code></pre>

<p>我们创建了一个Set实例，声明其持有String。</p>

<p>我们用<code>用insert(_:)方法</code>可以往这个集合里添加一些数据</p>

<pre class="line-numbers"><code class="language-swift">groceryBag.insert(&quot;Apples&quot;) 
groceryBag.insert(&quot;Oranges&quot;) 
groceryBag.insert(&quot;Pineapple&quot;) 
</code></pre>

<p>遍历集合</p>

<pre class="line-numbers"><code class="language-swift">for food in groceryBag { 
    print(food) 
} 
</code></pre>

<p>新的创建集合</p>

<pre class="line-numbers"><code class="language-swift">var groceryBag = Set([&quot;Apples&quot;, &quot;Oranges&quot;, &quot;Pineapple&quot;]) 
var groceryBag: Set = [&quot;Apples&quot;, &quot;Oranges&quot;, &quot;Pineapple&quot;] 

</code></pre>

<h2 id="toc_1">运用集合</h2>

<p>Set类型提供了contains(_:)方法来查看其内部是否有某个特殊的元素</p>

<pre class="line-numbers"><code class="language-swift">let hasBananas = groceryBag.contains(&quot;Bananas&quot;) 
</code></pre>

<p>hasBananas的值为假，你的groceryBag里面没有香蕉。</p>

<h3 id="toc_2">合并</h3>

<pre class="line-numbers"><code class="language-swift">let friendsGroceryBag = Set([&quot;Bananas&quot;, &quot;Cereal&quot;, &quot;Milk&quot;, &quot;Oranges&quot;]) 
let commonGroceryBag = groceryBag.union(friendsGroceryBag) 
</code></pre>

<p>这段代码增加了一个新的Set常量来表示你朋友的食品袋，并且用<code>union(_:)方法</code>把两个集合合并起来。<code>union(_:)</code>是Set类型的一个方法，接受一个SequenceType参数，并返回一个新的Set实例。该实例包含了两个容器中去重后的元素。简单地说，你可以把字典和集合传给<code>union(_:)</code>并得到一个包含合并后元素的集合，不会有重复。</p>

<h3 id="toc_3">交集</h3>

<pre class="line-numbers"><code class="language-swift">let roommatesGroceryBag = Set([&quot;Apples&quot;, &quot;Bananas&quot;, &quot;Cereal&quot;,&quot;Toothpaste&quot;]) 
let itemsToReturn = commonGroceryBag.intersection(roommatesGroceryBag) 
</code></pre>

<p>集合提供了<code>intersection(_:)</code>方法来找出同时存在于两个容器中的元素，并用一个新的Set实例返回这些重复的元素。图11-2用韦恩图的形式说明了这种关系。你室友的食品袋和你的有几样重复，不过不是所有都重复。</p>

<h3 id="toc_4">不相交</h3>

<pre class="line-numbers"><code class="language-swift">let yourSecondBag = Set([&quot;Berries&quot;, &quot;Yogurt&quot;]) 
let roommatesSecondBag = Set([&quot;Grapes&quot;, &quot;Honey&quot;]) 
let disjoint = yourSecondBag.isDisjoint(with: roommatesSecondBag) 
</code></pre>

<p>根据是否有集合（如yourSecondBag）的任何成员出现在作为参数提供给isDisjoint的序列（如roommatesSecondBag）中，Set的isDisjoint(with:)方法会返回真或假。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift编程入门（9）字典]]></title>
    <link href="https://hyter.me/swift-learning-9.html"/>
    <updated>2018-12-20T21:07:55+08:00</updated>
    <id>https://hyter.me/swift-learning-9.html</id>
    <content type="html"><![CDATA[
<p>当容器中的元素顺序很重要时，<code>Array</code>类型很有用。<br/>
然而顺序不总是很重要。有时候我们只是想在容器中持有一组数据，并在需要时获取信息。这就是<code>字典（dictionary）</code>的使用场景。<br/>
Dictionary使用键值对（key-value pair）组织其内容的容器类型。字典的键映射到值。<br/>
Dictionary中的键必须是唯一的。这个要求意味着每个键都唯一地映射到对应的值。<br/>
<span id="more"></span><!-- more --></p>

<ul>
<li>
<a href="#toc_0">创建字典</a>
</li>
<li>
<a href="#toc_1">初始化字典</a>
</li>
<li>
<a href="#toc_2">访问和修改字典</a>
<ul>
<li>
<a href="#toc_3">获取字典的元素个数</a>
</li>
<li>
<a href="#toc_4">读取值</a>
</li>
<li>
<a href="#toc_5">修改值</a>
</li>
<li>
<a href="#toc_6">更新值</a>
</li>
<li>
<a href="#toc_7">增加值</a>
</li>
<li>
<a href="#toc_8">删除值</a>
</li>
<li>
<a href="#toc_9">把一个键的值设为nil</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">循环</a>
<ul>
<li>
<a href="#toc_11">遍历字典</a>
</li>
<li>
<a href="#toc_12">只访问键</a>
</li>
</ul>
</li>
<li>
<a href="#toc_13">不可变字典</a>
</li>
<li>
<a href="#toc_14">把字典转换为数组</a>
</li>
</ul>


<h2 id="toc_0">创建字典</h2>

<p>创建Swift字典的通用语法如下：<code>var dict: Dictionary&lt;Key, Value&gt;</code>。这行代码创建一个Dictionary的可变实例，名叫dict。对字典的键和值接受什么类型的声明位于尖括号（&lt;&gt;）中，这里用Key和Value表示。<br/>
对于Swift中Dictionary类型的键，唯一的要求是其必须可散列（hashable）：也就是每个Key必须提供一种机制让Dictionary保证任何给定的键都是唯一的。Swift的基本类型都是可散列的，比如String、Int、Float、Double和Bool。<br/>
看获得一个Dictionary实例的不同方法.</p>

<pre class="line-numbers"><code class="language-swift">var dict1: Dictionary&lt;String, Double&gt; = [:] 
var dict2 = Dictionary&lt;String, Double&gt;() 
var dict3: [String:Double] = [:] 
var dict4 = [String:Double]() 
</code></pre>

<p>这4种方法得到的是同样的结果：经过完整初始化的Dictionary类型的实例，以及其键值的类型信息。Key被设置为接受String类型的键，而Value被设置为接受Double类型的值。在这4种情况下，字典实例都是空的：没有键也没有值。<br/>
[:]和()语法有什么区别呢？本质上是一样的。两者都创建并准备好了Dictionary类型的实例。[:]使用字面量语法创建Dictionary类型的空实例，并且会使用声明中提供的类型信息束键和值。比如说，dict1指定其类型并被初始化为空字典。()语法则使用Dictionary类型的默认初始化方法，这个方法会准备一个空的字典实例。本书后面部分会详细介绍初始化方法。</p>

<h2 id="toc_1">初始化字典</h2>

<pre class="line-numbers"><code class="language-swift">var movieRatings = [&quot;Donnie Darko&quot;: 4, &quot;Chungking Express&quot;: 5, &quot;Dark City&quot;: 4]
</code></pre>

<h2 id="toc_2">访问和修改字典</h2>

<h3 id="toc_3">获取字典的元素个数</h3>

<pre class="line-numbers"><code class="language-swift">import Cocoa 
var movieRatings = [&quot;Donnie Darko&quot;: 4, &quot;Chungking Express&quot;: 5, &quot;Dark City&quot;: 4] 
print(&quot;I have rated \(movieRatings.count) movies.&quot;)
</code></pre>

<p>使用字典的<code>count</code>属性</p>

<h3 id="toc_4">读取值</h3>

<pre class="line-numbers"><code class="language-swift">import Cocoa 
var movieRatings = [&quot;Donnie Darko&quot;: 4, &quot;Chungking Express&quot;: 5, &quot;Dark City&quot;: 4] 
print(&quot;I have rated \(movieRatings.count) movies.&quot;) 
let darkoRating = movieRatings[&quot;Donnie Darko&quot;]
</code></pre>

<h3 id="toc_5">修改值</h3>

<pre class="line-numbers"><code class="language-swift">import Cocoa 
var movieRatings = [&quot;Donnie Darko&quot;: 4, &quot;Chungking Express&quot;: 5, &quot;Dark City&quot;: 4] 
print(&quot;I have rated \(movieRatings.count) movies.&quot;) 
let darkoRating = movieRatings[&quot;Donnie Darko&quot;] 
movieRatings[&quot;Dark City&quot;] = 5 
movieRatings
</code></pre>

<h3 id="toc_6">更新值</h3>

<p>还有一种有用的方式可以更新与字典的键相关联的值：<code>updateValue(_:forKey:)</code>方法。这<br/>
个方法接受两个参数：value: Value和forKey: Key。第一个参数value接受新的值，第二个<br/>
参数forKey指定哪个键需要改变值。<br/>
这个方法之所以有用，是因为它能保存该键之前映射的值。还有个小小的警告：<code>updateValue(_:forKey:)</code>返回可空类型。这种返回类型很方便，因为这个键可能在字典中不存在。因此，把<code>updateValue(_:forKey:)</code>的返回值赋给一个预期类型的可空实例，并用可空实例绑定来获取这个键的旧值会很有用。</p>

<pre class="line-numbers"><code class="language-swift">import Cocoa 
var movieRatings = [&quot;Donnie Darko&quot;: 4, &quot;Chungking Express&quot;: 5, &quot;Dark City&quot;: 4] 
print(&quot;I have rated \(movieRatings.count) movies.&quot;) 
let darkoRating = movieRatings[&quot;Donnie Darko&quot;] 
movieRatings[&quot;Dark City&quot;] = 5 
movieRatings 
let oldRating: Int? = movieRatings.updateValue(5, forKey: &quot;Donnie Darko&quot;) 
if let lastRating = oldRating, let currentRating = movieRatings[&quot;Donnie Darko&quot;] { 
print(&quot;Old rating: \(lastRating); current rating: \(currentRating)&quot;) 
}
</code></pre>

<h3 id="toc_7">增加值</h3>

<pre class="line-numbers"><code class="language-swift">movieRatings[&quot;The Cabinet of Dr. Caligari&quot;] = 5
</code></pre>

<p>这里用语法<code>movieRatings[&quot;The Cabinet of Dr. Caligari&quot;] = 5</code>给字典增加了新的键值对。赋值运算符将值（本例中是5）关联到了新键（&quot;The Cabinet of Dr. Caligari&quot;上。</p>

<h3 id="toc_8">删除值</h3>

<pre class="line-numbers"><code class="language-swift">movieRatings.removeValue(forKey: &quot;Dark City&quot;)
</code></pre>

<p><code>removeValue(forKey:)</code>方法接受一个键作为参数，将与其匹配的键值对删除。</p>

<h3 id="toc_9">把一个键的值设为nil</h3>

<pre class="line-numbers"><code class="language-swift">movieRatings[&quot;Dark City&quot;] = nil
</code></pre>

<p>结果在本质上和删除一样的，但是这样写不会返回被删除键的值。</p>

<h2 id="toc_10">循环</h2>

<h3 id="toc_11">遍历字典</h3>

<pre class="line-numbers"><code class="language-swift">for (key, value) in movieRatings { 
    print(&quot;The movie \(key) was rated \(value).&quot;) 
}
</code></pre>

<h3 id="toc_12">只访问键</h3>

<pre class="line-numbers"><code class="language-swift">for movie in movieRatings.keys { 
    print(&quot;User has rated \(movie).&quot;) 
}
</code></pre>

<h2 id="toc_13">不可变字典</h2>

<p>创建不可变字典和创建不可变数组差不多，用let关键字告诉Swift编译器这个Dictionary实例不可变。</p>

<pre class="line-numbers"><code class="language-swift">let album = [&quot;Diet Roast Beef&quot;: 268, 
            &quot;Dubba Dubbs Stubs His Toe&quot;: 467, 
            &quot;Smokey&#39;s Carpet Cleaning Service&quot;: 187, 
            &quot;Track 4&quot;: 221] 
</code></pre>

<h2 id="toc_14">把字典转换为数组</h2>

<p>有时候把字典中的信息取出并放入数组会很有用。合理的做法是用字典的键创建一个Array.</p>

<pre class="line-numbers"><code class="language-swift">let watchedMovies = Array(movieRatings.keys)
</code></pre>

]]></content>
  </entry>
  
</feed>
